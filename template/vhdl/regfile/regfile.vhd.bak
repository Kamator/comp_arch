library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.core_pkg.all;
use work.mem_pkg.all;--?

entity regfile is
    port (
        clk              : in  std_logic;
        reset            : in  std_logic;
        stall            : in  std_logic;
        rdaddr1, rdaddr2 : in  reg_adr_type;
        rddata1, rddata2 : out data_type;
        wraddr           : in  reg_adr_type;
        wrdata           : in  data_type;
        regwrite         : in  std_logic
    );
end entity;

architecture rtl of regfile is
    type REG_MEMORY is array (0 to REG_COUNT-1) of std_logic_vector(DATA_WIDTH_BITS-1 downto 0);
    signal reg_file, reg_file_next : REG_MEMORY := (others => (others => '0'));
    signal rdaddr1_next, rdaddr2_next : reg_adr_type := (others => '0');
begin
    sync : process(reset, clk, stall)
    begin
        if reset = '0' then
            reg_file <= (others => (others => '0'));
            rdaddr1 <= (others => '0');
            rdaddr2 <= (others => '0');
        elsif rising_edge(clk) and stall = '0' then --stall causes the circuit not to latch input values
            reg_file <= reg_file_next;
            rdaddr1 <= rdaddr1_next;
            rdaddr2 <= rdaddr2_next;
        end if;
    
    end process;
    
    reg_file_read : process(all)
    begin
        rdaddr1_next <= reg_file(to_integer(unsigned(rdaddr1)));
        rdaddr2_next <= reg_file(to_integer(unsigned(rdaddr2)));
        
        if rdaddr1 = wraddr and (rdaddr2 = (others => '0')) and regwrite = '1' then
            rddata1 <= wrdata;
        elsif (rdaddr1 = (others => '0')) and rdaddr2 = wraddr and regwrite = '1' then
            rddata2 <= wrdata;
        end if;    
    end process;
    
    reg_file_write : process(all)
    begin
        if regwrite = '1' and wraddr /= (others => '0') then
            reg_file_next(to_integer(unsigned(wraddr))) <= wrdata;
        end if;    
    end process;
    
end architecture;
